---
name: cursor-global-rules
description: Global rules for Cursor development environment by Cody
alwaysApply: true
priority: 5
---
# Cursor Global Rules Cheatsheet [NOT NEGLIGIBLE]

These rules are mandatory and must be followed strictly in all interactions within the Cursor development environment. They ensure consistency, accuracy, and efficiency in development tasks. Violating these rules may lead to suboptimal outcomes—always refer back to this cheatsheet as needed.

## Python Environment Management
- Prioritize `uv` as the primary Python command; fallback to `python` or `python3` only if `uv` is unavailable or incompatible.
- Execute Python code using `uv run` (e.g., `uv run script.py`); avoid `uv python` or direct `python` invocation unless necessary.
- Install packages exclusively with `uv add` (e.g., `uv add requests`); do not use `uv pip install`, `pip install`, or other package managers.

## Thinking and Planning Process
- Employ `sequential-thinking` to meticulously plan all steps, reasoning, and potential branching paths before execution.
- Integrate `web search` and `context7` tools for information gathering; always perform search verification (e.g., cross-check results for accuracy and relevance) before advancing to the next round of thinking.
- Use the `fetch` tool to retrieve and review detailed content from searched web pages or resources.
- Conduct at least five rounds of structured thinking per task: include divergent brainstorming, explore alternative approaches, and branch into "what-if" scenarios.
- After each round, reflect critically on your decisions—evaluate based on query results, identify any gaps or errors, and adjust your approach accordingly.

## Tool and Context Usage
- Automatically invoke `context7` for tasks involving code generation, setup/configuration steps, or library/API documentation. This includes resolving library IDs and fetching relevant docs without explicit user prompts.
- Verify all file paths (e.g., via directory listings or checks) before any creation, editing, or reference to ensure they are accurate and exist as expected.

## User Interaction and Feedback
- Use the `interactive_feedback` MCP command to request clarification when instructions are ambiguous, incomplete, or conflicting.
- Formulate specific, targeted follow-up questions in `interactive_feedback` to resolve uncertainties—avoid making assumptions about user intent.
- Deeply analyze the user’s goals, project context, and overall objectives before proposing any solutions or changes.
- Communicate in a clear, concise, professional tone: be direct, avoid redundancy, and structure responses logically (e.g., use bullet points or numbered lists for steps).
- For recommendations, task summaries, or decision points, invoke `interactive_feedback` to solicit user input. If no response is received, proceed to conclude the task without repeating the command.
- When appropriate, provide predefined options (e.g., "Option 1: ... Option 2: ...") in `interactive_feedback` to facilitate quicker user decisions.
- Before finalizing any task or change, use `interactive_feedback` for confirmation. If no feedback is provided, complete the task without repetition.

## File and Edit Handling
- For large files, process incrementally: read from the last unread line onward until the entire file is covered, to manage memory and focus efficiently.
- Limit edits strictly to the relevant sections or context; always adhere to any applicable specification documents or guidelines.
- Do not create additional files unless explicitly instructed by the user or if it is critically necessary for task completion (e.g., essential configuration files without alternatives).
- Never execute `git commit` or `git push` commands—leave version control actions to the user.

## OpenSpec Integration
- Drive all development decisions using OpenSpec documentation located in the `openspec` folder as the authoritative source.
- Utilize OpenSpec slash commands for lifecycle management:
  - `/openspec-proposal`: To create new proposals.
  - `/openspec-apply`: To implement approved changes.
  - `/openspec-archive`: To archive completed or obsolete specs.
- For each issue or change, generate a dedicated OpenSpec change proposal, including a thorough analysis in clear English (covering impact, rationale, alternatives, and risks).
- After executing `openspec list`, pause for at least 20 seconds to allow for processing or user review before continuing.
- Update existing OpenSpec proposals promptly when new user input, requirements, or feedback is received.
- Automatically open `@/openspec/AGENTS.md` in scenarios involving:
  - Planning, proposals, or keywords like "spec," "change," "plan," or "architecture."
  - Introducing new capabilities, breaking changes, major architecture shifts, or significant work on performance/security.
  - Unclear or evolving requirements that require formal specification before proceeding to coding.
- Refer to `@/openspec/AGENTS.md` for guidance on:
  - Creating and applying change proposals.
  - Adhering to specification formats, conventions, and best practices.
  - Understanding project structure, guidelines, and overall workflow.

Adhere to these rules without exception to maintain high-quality, reliable development practices. If a conflict arises between rules, prioritize user safety, project integrity, and explicit instructions.
